using System;using System.Xml;using System.Xml.Schema;using System.Collections;using System.Web.Services.Description;namespace HWSProxyGen {	/// <summary>	/// Classe que representa as informações importantes do WSDL.	/// </summary>	public class ProxyModel {		private string name;		private string uri;		private string nameSpace;		private ArrayList functions = new ArrayList();		private ArrayList enumerations = new ArrayList();		private ArrayList dataTypes = new ArrayList();		private ArrayList listTypes = new ArrayList();		public string Name {			get { return name; }			set { name = value; }		}		public string Uri {			get { return uri; }			set { uri = value; }		}		public ArrayList Functions {			get { return functions; }			set { functions = value; }		}		public ArrayList Enumerations {			get { return enumerations; }			set { enumerations = value; }		}		public ArrayList DataTypes {			get { return dataTypes; }			set { dataTypes = value; }		}		public ArrayList ListTypes {			get { return listTypes; }			set { listTypes = value; }		}		public string NameSpace {			get { return nameSpace; }			set { nameSpace = value; }		}		public int FunctionsCount() {			return functions.Count;		}				/// <summary>		/// Creates a new <see cref="ProxyModel"/> instance.		/// </summary>		/// <param name="xmlDoc">XML doc.</param>		public ProxyModel(ServiceDescription servDesc) { 			Uri = servDesc.RetrievalUrl;			Name = servDesc.Services[0].Name;			MountTypes(servDesc);			AssignParameters();			MountFunctions(servDesc);			NameSpace = servDesc.TargetNamespace.ToString();		}		/// <summary>		/// 		/// </summary>		/// <param name="servDesc"></param>		private void MountTypes(ServiceDescription servDesc) {			foreach (XmlSchema xmlSch in servDesc.Types.Schemas) {				for (int i = 0; i < xmlSch.Items.Count; ++i) {					if (xmlSch.Items[i].GetType().Equals(typeof(XmlSchemaElement))) {						//TODO: verificar o que significa esse caso					} 					else if (xmlSch.Items[i].GetType().Equals(typeof(XmlSchemaComplexType))) {						MountComplexType((XmlSchemaComplexType) xmlSch.Items[i]);					} 					else if (xmlSch.Items[i].GetType().Equals(typeof(XmlSchemaSimpleType))) {						MountSimpleType((XmlSchemaSimpleType) xmlSch.Items[i]);					}				}			}		}		/// <summary>		/// 		/// </summary>		/// <param name="simpleType"></param>		/// <returns></returns>		private void MountSimpleType(XmlSchemaSimpleType simpleType) {						if (simpleType.Content.GetType().Equals(typeof(XmlSchemaSimpleTypeRestriction))) {				string name = simpleType.Name;				ArrayList enumMembers = new ArrayList();				XmlSchemaSimpleTypeRestriction rest = 					(XmlSchemaSimpleTypeRestriction) simpleType.Content;				//Nao necessiariamente essas facetas sao XmlSchemaEnumerationFacet				//Tem-se que se fazer um estudo mais detalhado dos tipos				//que podem aparecer aqui. (tipo inesperado causara' erro!)				foreach (XmlSchemaEnumerationFacet facet in rest.Facets) {					enumMembers.Add(facet.Value);				}				if (enumMembers.Count > 0) {					enumerations.Add(new Enumeration(name, enumMembers));				}									}		}		/// <summary>		/// Varre o documento wsdl e monta os data types especificados no mesmo		/// </summary>		/// <param name="xmlDoc">o documento wsdl</param>		/// <param name="xmlns">XmlNamespaceManager</param>		/// <returns>a lista de data types</returns>		private void MountComplexType(XmlSchemaComplexType complexType) { //XmlDocument xmlDoc, XmlNamespaceManager xmlns) 			string typeName = "";			ArrayList parameters = new ArrayList();			bool isArray = false;			HWSListType listType = null;			DataType dataType = null;						typeName = complexType.Name;////			tipos ainda nao suportados			if (complexType.Particle == null ||				!typeof(XmlSchemaGroupBase).IsAssignableFrom(complexType.Particle.GetType())) {				try {					XmlSchemaComplexContentRestriction restriction = complexType.ContentModel.Content as XmlSchemaComplexContentRestriction;					XmlSchemaAttribute att = (XmlSchemaAttribute) restriction.Attributes[0];					if (att.RefName.Name == "arrayType") {						XmlSchemaAnnotated annotatedSchema = (XmlSchemaAnnotated) att;						Parameter param = new Parameter();						param.Name = MakeArrayElementName(att.UnhandledAttributes[0].Value);						try {							param.HWSType = ConvertType(param.Name);						} 						catch {							param.HWSType = new HWSPreType(param.Name);						}						parameters.Add(param);						listType = new HWSListType(typeName, (Parameter)parameters[0]);						ListTypes.Add(listType);					}				} catch (Exception ex) {					throw new TypeNotSupportedException(typeName);				}			} else {							XmlSchemaGroupBase atts = (XmlSchemaGroupBase)complexType.Particle;				foreach (XmlSchemaElement att in atts.Items) {					Parameter param = new Parameter();					param.Name = att.Name;									try {						param.HWSType = ConvertType(att.SchemaTypeName.Name);					} 					catch {						param.HWSType = new HWSPreType(att.SchemaTypeName.Name);					}					if (att.MaxOccursString != null 						&& att.MaxOccursString.Equals("unbounded")) {						isArray = true;					}					parameters.Add(param);				}				if (isArray) {					listType = new HWSListType(typeName, (Parameter)parameters[0]);					ListTypes.Add(listType);				} 				else {					dataType = new DataType(typeName, parameters);					DataTypes.Add(dataType);				}			}		}		/// <summary>		/// Monta as funcoes do servico		/// </summary>		/// <param name="servDesc">descricao do servico</param>		private void MountFunctions(ServiceDescription servDesc) {			string funName = "";			HWSType returnType = null;			foreach (PortType port in servDesc.PortTypes) {				foreach (Operation op in port.Operations) {					ArrayList parameters = new ArrayList();					funName = op.Name;										//mensagem que descreve as entradas da operacao					Message msgIn = servDesc.Messages[op.Messages.Input.Message.Name];					foreach (MessagePart part in msgIn.Parts) {						//se for um element (padrao VS), o tipo da funcao						//esta' definido junto aos complex types						if (part.Element!= null && !part.Element.IsEmpty) {							//busca entre as definicoes dos types							foreach (XmlSchema s in servDesc.Types.Schemas) {								for (int i = 0; i < s.Items.Count; ++i) {									if (s.Items[i].GetType().Equals(typeof(XmlSchemaElement))) {										XmlSchemaElement e = (XmlSchemaElement) s.Items[i];																				if (e.Name.Equals(part.Element.Name)) {											XmlSchemaSequence seq = (XmlSchemaSequence)((XmlSchemaComplexType) e.SchemaType).Particle;																						if (seq != null) {												foreach (XmlSchemaElement param in seq.Items) {													Parameter p = new Parameter();													p.Name = param.Name;													p.HWSType = ConvertType(param.SchemaTypeName.Name);													parameters.Add(p);												}											}										}									}								}							}													}							//para os tipos definidos diretamente na mensagem						else {							Parameter p = new Parameter();							p.Name = part.Name;							p.HWSType = ConvertType(part.Type.Name);							parameters.Add(p);						}					}					//mensagem que descreve o retorno da operacao					Message msgOut = servDesc.Messages[op.Messages.Output.Message.Name];					foreach (MessagePart part in msgOut.Parts) {						//se for um element (padrao VS), o tipo da funcao						//esta' definido junto aos complex types						if (part.Element!= null && !part.Element.IsEmpty) {							//busca entre as definicoes dos types							foreach (XmlSchema s in servDesc.Types.Schemas) {								for (int i = 0; i < s.Items.Count; ++i) {									if (s.Items[i].GetType().Equals(typeof(XmlSchemaElement))) {										XmlSchemaElement e = (XmlSchemaElement) s.Items[i];																				if (e.Name.Equals(part.Element.Name)) {											XmlSchemaComplexType seq = (XmlSchemaComplexType) e.SchemaType;											XmlSchemaSequence seqParticle = null;											if (seq != null) {												seqParticle = (XmlSchemaSequence) seq.Particle;											}											 																						if (seqParticle != null) {													//sempre havera' apenas 1 elemento, afinal, e' o tipo de retorno												foreach (XmlSchemaElement param in seqParticle .Items) {													returnType = ConvertType(param.SchemaTypeName.Name);												}											}											else {												returnType = new HWSPrimitiveType(typeof(void));											}										}																			}								}							}													}							//para os tipos definidos diretamente na mensagem						else {							returnType = ConvertType(part.Type.Name);						}					}					Function function = new Function(funName, returnType, null, parameters);										if(SetSoapActionInFunction(servDesc, function)) {						this.functions.Add(function);					}				}			}		}				/// <summary>		/// Converte uma string em formato wsdl em um tipo basico da linguagem		/// ex: "s:string" -> string		/// </summary>		/// <param name="stringType">tipo em formato string</param>		/// <returns>tipo convertido</returns>		private HWSType ConvertType(string stringType) {			HWSType result = null;			stringType = stringType.Substring(stringType.IndexOf(":") + 1);						switch (stringType) {				case "int": 					result = new HWSPrimitiveType(typeof(int));					break;				case "double": 					result = new HWSPrimitiveType(typeof(double));					break;				case "long": 					result = new HWSPrimitiveType(typeof(long));					break;				case "string": 					result = new HWSPrimitiveType(typeof(string));					break;				case "char": 					result = new HWSPrimitiveType(typeof(char));					break;				case "float": 					result = new HWSPrimitiveType(typeof(float));					break;				case "void":					result = new HWSPrimitiveType(typeof(void));					break;				case "boolean":					result = new HWSPrimitiveType(typeof(bool));					break;				case "base64Binary": //TODO: interpret this value correctly					result = new HWSPrimitiveType(typeof(string));					break;				default:					bool found = false;					foreach (Enumeration en in this.enumerations) {						if (stringType.Equals(en.Name)) {							result = new HWSEnumType(stringType);							found = true;							break;						}					}					foreach (DataType data in this.dataTypes) {						if (stringType.Equals(data.Name)) {							bool hasParameters = data.Parameters.Count > 0;							result = new HWSDataTypeType(stringType, hasParameters);							found = true;							break;						}					}					foreach (HWSListType listType in this.listTypes) {						if (stringType.Equals(listType.Name)) {							result = listType;							found = true;							break;						}					}					if (!found) {						throw new TypeNotSupportedException(stringType);					}					break;			}			return result;		}				private void AssignParameters() {			foreach (DataType dt in this.DataTypes) {				foreach (Parameter p in dt.Parameters) {					if (p.HWSType is HWSPreType) {						HWSPreType preType = p.HWSType as HWSPreType;						p.HWSType = ConvertType(preType.Name);					}				}			}			foreach (HWSListType dt in this.listTypes) {				if (dt.Parameter.HWSType is HWSPreType) {					HWSPreType preType = dt.Parameter.HWSType as HWSPreType;					dt.Parameter.HWSType = ConvertType(preType.Name);				}			}		}		/// <summary>		/// Busca o atributo soapAction correspondente a funcao especificada e		/// atribui o valor na funcao		/// </summary>		/// <param name="servDesc">descricao o servico</param>		/// <param name="function">funcao a ser atualizada</param>		/// <returns></returns>		private static bool SetSoapActionInFunction(ServiceDescription servDesc, Function function) {			bool result = false;			foreach (Binding b in servDesc.Bindings) {				foreach (OperationBinding op in b.Operations) {					if (op.Name.Equals(function.Name)) {						if (op.Extensions[0] is SoapOperationBinding) {							SoapOperationBinding sob = (SoapOperationBinding)op.Extensions[0];							function.SoapAction = sob.SoapAction;							result = true;						}					}				}			}			return result;		}		private string MakeArrayElementName(string completeName) {			if (completeName.EndsWith("[]")) {				completeName = completeName.Replace("[]","");				}			int lastIndex = completeName.LastIndexOf(":");			return completeName.Substring(lastIndex);		}	}}